# 小程序的学习记录

## 前言

最近疫情之下，小程序又火了一波。很多线下企业转线上。只要是那些电商（卖东西），班级管理，健康码，网络会议等等，都是使用小程序实现的。为啥，快啊，节省成本。

所以啊，我又要学习一波小程序。小白时代听老师说过，而且自学过小程序，学的不深，半桶水的水平。工作以来维护过一次小程序，接触不多。刚好最近工作不算忙，有时间，那就学习一波。

其实，小程序很好理解的，特别对于熟悉`vue`前端开发的。只要把`vue`那一套的概念拿过来，对号入座的学习，在`vue`那里有的，自己思考或者搜索一番，能在小程序那里实现使用，就差不多了。

不要把小程序想的那么难，可以回想一下，打开一个`app`和小程序做对比，`app`里面的内容，业务比小程序多，而且体验比小程序好。小程序是2016出来的东西，初生之物，它大多数情况下负责实现一个产品的主要业务流程和主要的个人信息等等。其他的内容不会做太多，没有必要啊，那些都是展示在`app`里面。对比一下微博的`app`版和小程序版，很多次要的内容都是砍掉的。所以啊，对于瘦身型的小程序，我们开发者更不用怕。勇敢的写bug吧，流汗。

## 正文(小程序vsVue)

工作以来，使用的框架大多是`Vue`，所以来从`Vue`的角度来写吧。

#### 一、页面结构

vue的页面结构就是`template,script,style`，分别负责页面内容，逻辑，样式。小程序的页面就是一个文件夹，下面是`xx.js，xx.json，xx.wxml，xx.wxss`：js对应逻辑；wxml对应页面内容；wxss是样式。唯一的不同是.json这个文件，这个是页面配置，设置标签页的标题，样式，定义或者使用组件。

```json
{
  "usingComponents": {
    "reply": "../../components/reply/reply"
  }
}
```

`vue`定义或使用组件的代码是写在`script`里面的。

页面标签的话，查文档属性吧，不同名字的俩个是：view标签当作是div标签，这个标签的使用率很高。text对应span，主要是处理文字时不换行。其他的和Web那边的名字没什么不同。

#### 二、组件

写页面，组件是很重要的。组件是代码复用和页面拆分，提高编码效率和代码的可读性和维护性。

`Vue`的自定义组件，就是写个`vue`文件，在`props`接受父组件的传值，可能通过`$emit`需要返回值。

```
<template>
    //...省略很多行代码
</template>

<script>
export default{
    props: {
        sex: [String, Number],
        //sex: {
            //type: Number,
            //default: 0
        //}
    },
    //...省略很多行代码
}
</script>
```
[我第一次写的组件](https://www.cnblogs.com/StephenWu5/p/10956089.html)
https://www.cnblogs.com/StephenWu5/p/10956089.html

`Vue`的使用自定义组件很简单啊，`js`导入，在`components`声明，然后就可以愉快的使用了。

小程序的自定义组件：

在`json`文件中加上一句`"component": true`，使用`Component()`来注册组件，代码如下(这一套和Vue很像)：

```javascript
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    // 相当于 Vue里的props
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```

小程序自定义组件的使用：

```
//xxx.json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
//xxx.wxml
<!-- 以下是对一个自定义组件的引用 -->
<component-tag-name inner-text="Some text"></component-tag-name>
```

#### 三、传值（通讯）

vue 里面通讯有多种方式： props(父传子)，emit（子传父），provide(inject)(父到子子孙孙的传，不建议多使用)，cookie(少使用)，vuex 值（推荐，结合 cookie 使用）。**不能一味的使用同一种传参方式，按距离选择 props 和 vuex 的值。**

小程序有properties（对应props），triggerEvent（对应emit），storage(对应cookie)，没有大名鼎鼎的Vuex。大多数小程序业务算简单或者中等，就算没有Vuex，能满足大多数的业务需求。

有个大佬写了一个js实现了类似Vuex那样的功能，大家可以试试
[wxappStore](https://github.com/SBDavid/wxappStore)
https://github.com/SBDavid/wxappStore

还有搞个简易版的，我看了好一会才看懂,原理就是在`app.js`里面使用`Object.defineProperty`给`app.globalData`里面一个或者多个目标值设值，设值的后面紧跟着一个回填方法。在需要及时拿到`app.globalData`页面执行那个`app.js`方法并传入回调函数。代码如下：

```
//app.js 全局属性监听
 watch: function (method) {
     var obj = this.globalData;
     Object.defineProperty(obj, "data", { //这里的 data 对应 上面 globalData 中的 data
     configurable: true,
     enumerable: true,
     set: function (value) { //动态赋值，传递对象，为 globalData 中对应变量赋值
     this._showPictureDetail = value.showPictureDetail;
     this._pictureTime = value.pictureTime;
     this._pictureAddress = value.pictureAddress;
     method(value);
     },
     get: function () { //获取全局变量值，直接返回全部
     return this.globalData;
     }
     })
 },


//需要拿到值的页面
getApp().watch(self.watchBack)
 
//定义监听回调方法
//app 监听回调方法
 watchBack: function (value) { //这里的value 就是 app.js 中 watch 方法中的 set, 返回整个 globalData
     this.setData({
     showPictureDetail: value._showPictureDetail,
     pictureTime: value._pictureTime,
     pictureAddress: value._pictureAddress
     });
 },
```

这个方法的关键是对象的赋值会触发`Object.defineProperty下的set`，这是精华所在。有个缺点是，如果需要监听其他变量，必须搞一套类似的代码。改造一下吧。

改造也简单，A区代码，在app.js文件里面加入一个watchNameArr，说明哪些变量名要监听的，对象动态赋值时传来的值做下对比，如果在watchNameArr里面就赋值并监听，不在就不管。B区代码，作同样的处理。

```
//A区代码 app.js 全局属性监听
globalData: {
    watchNameArr: ['_showPictureDetail','_pictureTime','._pictureAddress'],
},
globalData: {
 watch: function (method) {
     var obj = this.globalData;
     Object.defineProperty(obj, "data", { //这里的 data 对应 上面 globalData 中的 data
     configurable: true,
     enumerable: true,
     set: function (value) { //动态赋值，传递对象，为 globalData 中对应变量赋值
         value.keys().reduce((pre,cur) =>{
            if(obj.wachNameArr.includes(cur)){
                 this[cur] = value[cur]      
            }
            return ''; //无脑return ''，这里没事
         },'')
     this._showPictureDetail = value.showPictureDetail;
     this._pictureTime = value.pictureTime;
     this._pictureAddress = value.pictureAddress;
     method(value);
     },
     get: function () { //获取全局变量值，直接返回全部
     return this.globalData;
     }
     })
 },


//B区代码 需要拿到值的页面
getApp().watch(self.watchBack)
let watchNameArr = getApp().globalData.wachNameArr;
 
//定义监听回调方法
//app 监听回调方法
 watchBack: function (value) { //这里的value 就是 app.js 中 watch 方法中的 set, 返回整个 globalData
     var targetObj = value.keys().reduce((pre,cur) => {
        if(!(cur in pre) && watchNameArr.include(cur)){
            pre[cur] = value[cur]
        }
        
        return pre;
     },{})
     this.setData(targetObj);
 },
```

改动过后就容易了：把A区代码搞到`app.js`，B区代码搞到需要变量的页面，就可以愉快的监听了。就一套或者说两套代码。low是low点，能用。我上一家公司的`Vue`项目不用`Vuex`使用`commonjs`里面的共同变量，连基本的监听都没写，一样拿到值。不写监听是因为不需要很频繁（多次）的改这个共同变量，还有就是大佬偷懒，这话是他自己说的。

#### 四、调用函数

父组件调用子组件的方法很简单，通过`this.selectComponent`拿到子组件的实力对象，直接访问内部的方法。这个`selectComponent`最好是放在`onShow`周期或者之后的周期，否则可能拿不到。这个东西和refs一样。

爷爷组件调用孙子组件的方法可以吗？`this.selectComponent('xxx')..selectComponent('xxx')`呗，虽然不是最好的方法，暂时先这样呗。

子组件调用父组件的方法使用`this.triggerEvent`，套路和`vue`的`emit`一毛一样：

```javascript
this.triggerEvent('myevent', myEventDetail, myEventOption)
```

孙子组件调用爷爷组件的方法就是把上面的方法的第三个参数改下，开启冒泡。

```javascript
this.triggerEvent('customevent', {}, { bubbles: true }) 
```

#### 五、computed 计算属性与 watch 监听

很幸运，这两个功能微信官方文档已经实现了。安装`miniprogram-computed`依赖包，引入到`behaviors`属性，像`vue`那样使用就可以了。看来尤大影响力挺大的。

```
const computedBehavior = require('miniprogram-computed')
//...省略代码
behaviors: [computedBehavior],
//...省略代码
```

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/extended/utils/computed.html)
https://developers.weixin.qq.com/miniprogram/dev/extended/utils/computed.html

#### 六、生命周期

生命周期分应用的生命周期，页面的生命周期和组件的生命周期。

我要开始愉快的抄（或者说借鉴）别人的博客，就是这样的菜。

应用生命周期写在`app.js`里面，前台后台的意思就是在用小程序时，需要去别的`app`看下，此时，小程序从前台进入后台。

```javascript
App({
  onLaunch: function(options) {
    // 监听小程序初始化。小程序初始化完成时（全局只触发一次）
  },
  onShow: function(options) {
    // 监听小程序显示。小程序启动，或从后台进入前台显示时
  },
  onHide: function() {
    // 监听小程序隐藏。小程序从前台进入后台时。
  },
  onError: function(msg) {
    console.log(msg) // 错误监听函数。小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息
  },
  onPageNotFound: function(res) {
    // 页面不存在监听函数。小程序要打开的页面不存在时触发，会带上页面信息回调该函数
  },
})
```

页面生命周期

```javascript
//index.js
Page({
  data: {
    // 页面的初始数据
    text: "This is page data."
  },
  onLoad: function(options) {
    // 生命周期回调—监听页面加载
  },
  onReady: function() {
    // 生命周期回调—监听页面初次渲染完成
    // 只会执行一次
  },
  onShow: function() {
    // 生命周期回调—监听页面显示
    // 一般在这里获取实例对象
  },
  onHide: function() {
    // 生命周期回调—监听页面隐藏
  },
  onUnload: function() {
    // 生命周期回调—监听页面卸载
  },
  onPullDownRefresh: function() {
    // 监听用户下拉动作 --需要开启配置
  },
  onReachBottom: function() {
    // 页面上拉触底事件的处理函数 --需要开启配置
  },
  onShareAppMessage: function () {
    // 用户点击右上角转发
  },
  onPageScroll: function() {
    // 页面滚动触发事件的处理函数
  },
  onResize: function() {
    // 页面尺寸改变时触发
  },
  onTabItemTap(item) {
    // 当前是 tab 页时，点击 tab 时触发
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 任意的函数，在页面的函数中用 this 可以访问
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 任意数据，在页面的函数中用 this 可以访问
  customData: {
    hi: 'MINA'
  }
})
```

组件生命周期：

```javascript
Component({
  lifetimes: {
    created: function() {
      //在组件实例刚刚被创建时执行 
      //这里还不能使用`setData`
    },
    attached: function() {
      // 在组件实例进入页面节点树时执行
      // 组件实例初始化完成，包括this.data的值，大多数初始化工作从这个时候开始。 这个周期和Vue的mounted类似。
    },
    ready: function() {
      //在组件在视图层布局完成后执行 
    },
    moved: function() {
      //在组件实例被移动到节点树另一个位置时执行 
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
    error: function() {
      //每当组件方法抛出错误时执行 
    },
  },
  //组件所在页面的生命周期--这个有点特殊
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function(size) {
      // 页面尺寸变化
    }
  }
})
```

#### 七、路由跳转

#### 七、form表单

#### 七、微信登录，获取用户信息，微信授权



#### 七、缺点

混入，插槽，parent,这些概念是没有的，希望以后微信团队可以实现。


130小程序源码--家居电商：

统一封装了get和post请求，组件的学习。
